// Code generated by "go-option -type NodeLocator"; DO NOT EDIT.
// Install go-option by "go get install github.com/searKing/golang/tools/go-option"

package hashring

// A NodeLocatorOption sets options.
type NodeLocatorOption interface {
	apply(*NodeLocator)
}

// EmptyNodeLocatorOption does not alter the configuration. It can be embedded
// in another structure to build custom options.
//
// This API is EXPERIMENTAL.
type EmptyNodeLocatorOption struct{}

func (EmptyNodeLocatorOption) apply(*NodeLocator) {}

// NodeLocatorOptionFunc wraps a function that modifies NodeLocator into an
// implementation of the NodeLocatorOption interface.
type NodeLocatorOptionFunc func(*NodeLocator)

func (f NodeLocatorOptionFunc) apply(do *NodeLocator) {
	f(do)
}

// ApplyOptions call apply() for all options one by one
func (o *NodeLocator) ApplyOptions(options ...NodeLocatorOption) *NodeLocator {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}

// WithNodeLocator sets NodeLocator.
func WithNodeLocator(v NodeLocator) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		*o = v
	})
}

// WithNodeLocatorSortedKeys appends sortedKeys in NodeLocator.
// The List of nodes to use in the Ketama consistent hash continuum
//
// This simulates the structure of keys used in the Ketama consistent hash ring,
// which stores the virtual node HashKeys on the physical nodes.
// All nodes in the cluster are topped by virtual nodes.
// In principle, it is a brute-force search to find the first complete HashKey
//
// For example,
// Node ->       Key       ->      IterateKey     -> HashKey
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-0   ->  1234
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-160 ->  256
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-320 ->  692
// []HashKey, Index for nodes binary search
func WithNodeLocatorSortedKeys(v ...uint32) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.sortedKeys = append(o.sortedKeys, v...)
	})
}

// WithNodeLocatorSortedKeysReplace sets sortedKeys in NodeLocator.
// The List of nodes to use in the Ketama consistent hash continuum
//
// This simulates the structure of keys used in the Ketama consistent hash ring,
// which stores the virtual node HashKeys on the physical nodes.
// All nodes in the cluster are topped by virtual nodes.
// In principle, it is a brute-force search to find the first complete HashKey
//
// For example,
// Node ->       Key       ->      IterateKey     -> HashKey
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-0   ->  1234
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-160 ->  256
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-320 ->  692
// []HashKey, Index for nodes binary search
func WithNodeLocatorSortedKeysReplace(v ...uint32) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.sortedKeys = v
	})
}

// WithNodeLocatorNodeByKey appends nodeByKey in NodeLocator.
// <HashKey,Node>
func WithNodeLocatorNodeByKey(m map[uint32]Node) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		if o.nodeByKey == nil {
			o.nodeByKey = m
			return
		}
		for k, v := range m {
			o.nodeByKey[k] = v
		}
	})
}

// WithNodeLocatorNodeByKeyReplace sets nodeByKey in NodeLocator.
// <HashKey,Node>
func WithNodeLocatorNodeByKeyReplace(v map[uint32]Node) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.nodeByKey = v
	})
}

// WithNodeLocatorAllNodes appends allNodes in NodeLocator.
// <Node>
func WithNodeLocatorAllNodes(m map[Node]struct{}) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		if o.allNodes == nil {
			o.allNodes = m
			return
		}
		for k, v := range m {
			o.allNodes[k] = v
		}
	})
}

// WithNodeLocatorAllNodesReplace sets allNodes in NodeLocator.
// <Node>
func WithNodeLocatorAllNodesReplace(v map[Node]struct{}) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.allNodes = v
	})
}

// WithNodeLocatorHashAlg sets hashAlg in NodeLocator.
// The hash algorithm to use when choosing a node in the Ketama consistent hash continuum
func WithNodeLocatorHashAlg(v HashAlgorithm) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.hashAlg = v
	})
}

// WithNodeLocatorWeightByNode appends weightByNode in NodeLocator.
// node weights for ketama, a map from InetSocketAddress to weight as Integer
func WithNodeLocatorWeightByNode(m map[Node]int) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		if o.weightByNode == nil {
			o.weightByNode = m
			return
		}
		for k, v := range m {
			o.weightByNode[k] = v
		}
	})
}

// WithNodeLocatorWeightByNodeReplace sets weightByNode in NodeLocator.
// node weights for ketama, a map from InetSocketAddress to weight as Integer
func WithNodeLocatorWeightByNodeReplace(v map[Node]int) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.weightByNode = v
	})
}

// WithNodeLocatorIsWeighted sets isWeighted in NodeLocator.
func WithNodeLocatorIsWeighted(v bool) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.isWeighted = v
	})
}

// WithNodeLocatorNumReps sets numReps in NodeLocator.
// the number of discrete hashes that should be defined for each node in the continuum.
func WithNodeLocatorNumReps(v int) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.numReps = v
	})
}

// WithNodeLocatorNodeKeyFormatter sets nodeKeyFormatter in NodeLocator.
// the format used to name the nodes in Ketama, either SpyMemcached or LibMemcached
func WithNodeLocatorNodeKeyFormatter(v *KetamaNodeKeyFormatter) NodeLocatorOption {
	return NodeLocatorOptionFunc(func(o *NodeLocator) {
		o.nodeKeyFormatter = v
	})
}
