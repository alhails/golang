// Code generated by "go-option -type HashRing"; DO NOT EDIT.
// Install go-option by "go get install github.com/searKing/golang/tools/go-option"

package hashring

// A HashRingOption sets options.
type HashRingOption[Node comparable] interface {
	apply(*HashRing[Node])
}

// EmptyHashRingOption does not alter the configuration. It can be embedded
// in another structure to build custom options.
//
// This API is EXPERIMENTAL.
type EmptyHashRingOption[Node comparable] struct{}

func (EmptyHashRingOption[Node]) apply(*HashRing[Node]) {}

// HashRingOptionFunc wraps a function that modifies HashRing[Node] into an
// implementation of the HashRingOption[Node comparable] interface.
type HashRingOptionFunc[Node comparable] func(*HashRing[Node])

func (f HashRingOptionFunc[Node]) apply(do *HashRing[Node]) {
	f(do)
}

// ApplyOptions call apply() for all options one by one
func (o *HashRing[Node]) ApplyOptions(options ...HashRingOption[Node]) *HashRing[Node] {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}

// WithHashRing sets HashRing.
func WithHashRing[Node comparable](v HashRing[Node]) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		*o = v
	})
}

// WithHashRingSortedKeys appends sortedKeys in HashRing[Node].
// The List of nodes to use in the Ketama consistent hash continuum
//
// This simulates the structure of keys used in the Ketama consistent hash ring,
// which stores the virtual node HashKeys on the physical nodes.
// All nodes in the cluster are topped by virtual nodes.
// In principle, it is a brute-force search to find the first complete HashKey
//
// For example,
// Node ->       Key       ->      IterateKey     -> HashKey
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-0   ->  1234
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-160 ->  256
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-320 ->  692
// []HashKey, Index for nodes binary search
func WithHashRingSortedKeys[Node comparable](v ...uint32) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.sortedKeys = append(o.sortedKeys, v...)
	})
}

// WithHashRingSortedKeysReplace sets sortedKeys in HashRing[Node].
// The List of nodes to use in the Ketama consistent hash continuum
//
// This simulates the structure of keys used in the Ketama consistent hash ring,
// which stores the virtual node HashKeys on the physical nodes.
// All nodes in the cluster are topped by virtual nodes.
// In principle, it is a brute-force search to find the first complete HashKey
//
// For example,
// Node ->       Key       ->      IterateKey     -> HashKey
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-0   ->  1234
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-160 ->  256
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-320 ->  692
// []HashKey, Index for nodes binary search
func WithHashRingSortedKeysReplace[Node comparable](v ...uint32) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.sortedKeys = v
	})
}

// WithHashRingNodeByKey appends nodeByKey in HashRing[Node].
// <HashKey,Node>
func WithHashRingNodeByKey[Node comparable](m map[uint32]Node) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		if o.nodeByKey == nil {
			o.nodeByKey = m
			return
		}
		for k, v := range m {
			o.nodeByKey[k] = v
		}
	})
}

// WithHashRingNodeByKeyReplace sets nodeByKey in HashRing[Node].
// <HashKey,Node>
func WithHashRingNodeByKeyReplace[Node comparable](v map[uint32]Node) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.nodeByKey = v
	})
}

// WithHashRingAllNodes appends allNodes in HashRing[Node].
// <Node>
func WithHashRingAllNodes[Node comparable](m map[Node]struct{}) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		if o.allNodes == nil {
			o.allNodes = m
			return
		}
		for k, v := range m {
			o.allNodes[k] = v
		}
	})
}

// WithHashRingAllNodesReplace sets allNodes in HashRing[Node].
// <Node>
func WithHashRingAllNodesReplace[Node comparable](v map[Node]struct{}) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.allNodes = v
	})
}

// WithHashRingHashAlg sets hashAlg in HashRing[Node].
// The hash algorithm to use when choosing a node in the Ketama consistent hash continuum
func WithHashRingHashAlg[Node comparable](v HashAlgorithm) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.hashAlg = v
	})
}

// WithHashRingWeightByNode appends weightByNode in HashRing[Node].
// node weights for ketama, a map from InetSocketAddress to weight as Integer
func WithHashRingWeightByNode[Node comparable](m map[Node]int) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		if o.weightByNode == nil {
			o.weightByNode = m
			return
		}
		for k, v := range m {
			o.weightByNode[k] = v
		}
	})
}

// WithHashRingWeightByNodeReplace sets weightByNode in HashRing[Node].
// node weights for ketama, a map from InetSocketAddress to weight as Integer
func WithHashRingWeightByNodeReplace[Node comparable](v map[Node]int) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.weightByNode = v
	})
}

// WithHashRingIsWeighted sets isWeighted in HashRing[Node].
func WithHashRingIsWeighted[Node comparable](v bool) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.isWeighted = v
	})
}

// WithHashRingNumReps sets numReps in HashRing[Node].
// the number of discrete hashes that should be defined for each node in the continuum.
func WithHashRingNumReps[Node comparable](v int) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.numReps = v
	})
}

// WithHashRingNodeKeyFormatter sets nodeKeyFormatter in HashRing[Node].
// the format used to name the nodes in Ketama, either SpyMemcached or LibMemcached
func WithHashRingNodeKeyFormatter[Node comparable](v Formatter[Node]) HashRingOption[Node] {
	return HashRingOptionFunc[Node](func(o *HashRing[Node]) {
		o.nodeKeyFormatter = v
	})
}
