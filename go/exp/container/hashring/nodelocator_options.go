// Code generated by "go-option -type NodeLocator"; DO NOT EDIT.
// Install go-option by "go get install github.com/searKing/golang/tools/go-option"

package hashring

// A NodeLocatorOption sets options.
type NodeLocatorOption[Node comparable] interface {
	apply(*NodeLocator[Node])
}

// EmptyNodeLocatorOption does not alter the configuration. It can be embedded
// in another structure to build custom options.
//
// This API is EXPERIMENTAL.
type EmptyNodeLocatorOption[Node comparable] struct{}

func (EmptyNodeLocatorOption[Node]) apply(*NodeLocator[Node]) {}

// NodeLocatorOptionFunc wraps a function that modifies NodeLocator[Node] into an
// implementation of the NodeLocatorOption[Node comparable] interface.
type NodeLocatorOptionFunc[Node comparable] func(*NodeLocator[Node])

func (f NodeLocatorOptionFunc[Node]) apply(do *NodeLocator[Node]) {
	f(do)
}

// ApplyOptions call apply() for all options one by one
func (o *NodeLocator[Node]) ApplyOptions(options ...NodeLocatorOption[Node]) *NodeLocator[Node] {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}

// WithNodeLocator sets NodeLocator.
func WithNodeLocator[Node comparable](v NodeLocator[Node]) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		*o = v
	})
}

// WithNodeLocatorSortedKeys appends sortedKeys in NodeLocator[Node].
// The List of nodes to use in the Ketama consistent hash continuum
//
// This simulates the structure of keys used in the Ketama consistent hash ring,
// which stores the virtual node HashKeys on the physical nodes.
// All nodes in the cluster are topped by virtual nodes.
// In principle, it is a brute-force search to find the first complete HashKey
//
// For example,
// Node ->       Key       ->      IterateKey     -> HashKey
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-0   ->  1234
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-160 ->  256
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-320 ->  692
// []HashKey, Index for nodes binary search
func WithNodeLocatorSortedKeys[Node comparable](v ...uint32) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.sortedKeys = append(o.sortedKeys, v...)
	})
}

// WithNodeLocatorSortedKeysReplace sets sortedKeys in NodeLocator[Node].
// The List of nodes to use in the Ketama consistent hash continuum
//
// This simulates the structure of keys used in the Ketama consistent hash ring,
// which stores the virtual node HashKeys on the physical nodes.
// All nodes in the cluster are topped by virtual nodes.
// In principle, it is a brute-force search to find the first complete HashKey
//
// For example,
// Node ->       Key       ->      IterateKey     -> HashKey
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-0   ->  1234
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-160 ->  256
// {}	-> 127.0.0.1:11311 -> 127.0.0.1:11311-320 ->  692
// []HashKey, Index for nodes binary search
func WithNodeLocatorSortedKeysReplace[Node comparable](v ...uint32) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.sortedKeys = v
	})
}

// WithNodeLocatorNodeByKey appends nodeByKey in NodeLocator[Node].
// <HashKey,Node>
func WithNodeLocatorNodeByKey[Node comparable](m map[uint32]Node) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		if o.nodeByKey == nil {
			o.nodeByKey = m
			return
		}
		for k, v := range m {
			o.nodeByKey[k] = v
		}
	})
}

// WithNodeLocatorNodeByKeyReplace sets nodeByKey in NodeLocator[Node].
// <HashKey,Node>
func WithNodeLocatorNodeByKeyReplace[Node comparable](v map[uint32]Node) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.nodeByKey = v
	})
}

// WithNodeLocatorAllNodes appends allNodes in NodeLocator[Node].
// <Node>
func WithNodeLocatorAllNodes[Node comparable](m map[Node]struct{}) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		if o.allNodes == nil {
			o.allNodes = m
			return
		}
		for k, v := range m {
			o.allNodes[k] = v
		}
	})
}

// WithNodeLocatorAllNodesReplace sets allNodes in NodeLocator[Node].
// <Node>
func WithNodeLocatorAllNodesReplace[Node comparable](v map[Node]struct{}) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.allNodes = v
	})
}

// WithNodeLocatorHashAlg sets hashAlg in NodeLocator[Node].
// The hash algorithm to use when choosing a node in the Ketama consistent hash continuum
func WithNodeLocatorHashAlg[Node comparable](v HashAlgorithm) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.hashAlg = v
	})
}

// WithNodeLocatorWeightByNode appends weightByNode in NodeLocator[Node].
// node weights for ketama, a map from InetSocketAddress to weight as Integer
func WithNodeLocatorWeightByNode[Node comparable](m map[Node]int) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		if o.weightByNode == nil {
			o.weightByNode = m
			return
		}
		for k, v := range m {
			o.weightByNode[k] = v
		}
	})
}

// WithNodeLocatorWeightByNodeReplace sets weightByNode in NodeLocator[Node].
// node weights for ketama, a map from InetSocketAddress to weight as Integer
func WithNodeLocatorWeightByNodeReplace[Node comparable](v map[Node]int) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.weightByNode = v
	})
}

// WithNodeLocatorIsWeighted sets isWeighted in NodeLocator[Node].
func WithNodeLocatorIsWeighted[Node comparable](v bool) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.isWeighted = v
	})
}

// WithNodeLocatorNumReps sets numReps in NodeLocator[Node].
// the number of discrete hashes that should be defined for each node in the continuum.
func WithNodeLocatorNumReps[Node comparable](v int) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.numReps = v
	})
}

// WithNodeLocatorNodeKeyFormatter sets nodeKeyFormatter in NodeLocator[Node].
// the format used to name the nodes in Ketama, either SpyMemcached or LibMemcached
func WithNodeLocatorNodeKeyFormatter[Node comparable](v Formatter[Node]) NodeLocatorOption[Node] {
	return NodeLocatorOptionFunc[Node](func(o *NodeLocator[Node]) {
		o.nodeKeyFormatter = v
	})
}
